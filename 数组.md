[TOC]

# 数组

## 1. 二分查找

#### **704 题** (核心习题)

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

 

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。



**我的题解:**

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left)/2; //防止数据溢出，相当于int mid = (left + right) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else return mid;
        }
        return -1;
    }
}
```

**复杂度分析**

- 时间复杂度：*O*(log*n*)，其中 *n* 是数组的长度
- 空间复杂度：*O*(1)



#### 34 题 

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

 

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`



**我的题解:**

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftIndex = getLeftIndex(nums, target);
        int rightIndex = getRightIndex(nums, target);
        // 记得右范围要小于数组长度
        if (leftIndex <= rightIndex && rightIndex < nums.length)
            return new int[] { leftIndex, rightIndex };
        return new int[] { -1, -1 };
    }

    public int getLeftIndex(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int leftIndex = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 重点，设置退出条件
            if (nums[mid] == target) {
                leftIndex = mid;// 赋值是必要的
                right = mid - 1;// 目的是保证找到左边第一个target值时，下一轮立刻退出循环，巧计，找到左1就动右
            }
            if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        return leftIndex;
    }

    public int getRightIndex(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int rightIndex = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 重点，设置退出条件
            if (nums[mid] == target) {
                rightIndex = mid;// 赋值是必要的
                left = mid + 1;// 目的是保证找到左边第一个target值时，继续往后找，直到找到最后一个target，下一轮实现left > right，再下一轮退出循环，巧计，找到右1就动左
            }
            if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        return rightIndex;
    }
}
```



**复杂度分析**

- 时间复杂度： O(logn) , 其中 n 为数组的长度。二分查找的时间复杂度为 O(logn)，一共会执行两次，因此总时间复杂度为 O(logn)

- 空间复杂度：O(1) , 只需要常数空间存放若干变量



#### 69 题

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

 

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

 

**提示：**

- `0 <= x <= 2^31 - 1`



**我的题解:**

```java
class Solution {
    public int mySqrt(int x) {
        int ans = -1, left = 0, right = x;
        while (left <= right) {
            int mid = left + (right - left)/2;
            //本题最关键的点就在于下面循环中 if 的条件
            //不要 (long)(mid * mid)先计算可能大整数会数据溢出！
            long square = (long) mid * mid;
            if (square <= x) {
                ans = mid;
                left = mid + 1;
            } else right = mid - 1;
        }
        return ans;
    }
}
```



**复杂度分析**

- 时间复杂度：*O*(log*x*)，即为二分查找需要的次数
- 空间复杂度：*O*(1)



#### 367 题

给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如 `sqrt` 。

 

**示例 1：**

```
输入：num = 16
输出：true
解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
```

**示例 2：**

```
输入：num = 14
输出：false
解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
```

 

**提示：**

- `1 <= num <= 2^31 - 1`



**我的题解:**

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int left = 0, right = num;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            long square = (long) mid * mid;
            if (square < num) left = mid + 1; // 注意square是和num比较, 不是和mid比较!
            else if (square > num) right = mid - 1;
            else return true;
        }
        return false;
    }
}
```



**复杂度分析**

- 时间复杂度：*O*(log*n*)，其中 *n* 为正整数 *num* 的最大值。
- 空间复杂度：*O*(1)



## 2. 移除元素

学习快慢指针法 和 相向双指针法， 加动图， 且一定要解释清楚指针怎么走的！

#### 27题 (核心习题)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

**用户评测：**

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有的断言都通过，你的解决方案将会 **通过**。

 

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

 

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`



##### 题目分析: 

###### 暴力解法

这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。

删除过程如下：

![27.移除元素-暴力解法](images/%E6%95%B0%E7%BB%84/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif)

很明显暴力解法的时间复杂度是O(n^2)，这道题目暴力解法在leetcode上是可以过的



**我的题解:**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        //暴力解法
        int length = nums.length;
        for (int i = 0; i < length; i++) {
            if (val == nums[i]) { // 发现需要移除的元素，就将后续数组集体向前移动一位
                for (int j = i; j < length - 1/*防止下面越界*/; j++) {
                    nums[j] = nums[j + 1];
                }
                //nums[length - 1] = 0; 题目没要求, 不用管后面
                i--; //重点, 因为下标 i 以后的数值都向前移动了一位, 所以 i 也向前移动一位, 同步控制
                length--;
            }
        }
        return length;
    }
}
```



**复杂度分析**

- 时间复杂度：*O*(*n*)，其中 *n* 为序列的长度。我们只需要遍历该序列至多两次
- 空间复杂度：*O*(1)。我们只需要常数的空间保存若干变量





###### 双指针法 (快慢指针法)

双指针法（快慢指针法）： **通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作**



定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

很多同学这道题目做的很懵，就是不理解 快慢指针究竟都是什么含义，所以一定要明确含义，后面的思路就更容易理解了。

删除过程如下：当快指针遇到 val 时让慢指针停在该 index, 自己继续往下去移动直到找到一个非 val 值的 index , 覆盖慢指针处的值

![27.移除元素-双指针法](images/%E6%95%B0%E7%BB%84/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)

很多同学不了解

**双指针法（快慢指针法）**在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法



**我的题解:**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        //双指针法 (快慢指针法)
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) { //当快指针没指向val值的索引时
                nums[slowIndex] = nums[fastIndex]; //快指针 赋值覆盖给 慢指针
                slowIndex++;//同步控制
            }
        }
        return slowIndex; //刚好"新"数组末尾的下一个下标slowIndex 就是形成的"新"数组的大小
    }
}
```

**复杂度分析**

- 时间复杂度：*O*(*n*), 其中 *n* 为序列的长度. 我们只需要遍历该序列至多一次
- 空间复杂度：*O*(1), 我们只需要常数的空间保存若干变量



###### 双指针法 (相向双指针法)

**相向双指针法**是一种常用于解决数组或链表中问题的算法技巧。它的基本思想是使用两个指针，一个从数组或链表的起始位置开始向后移动，另一个从末尾位置开始向前移动，以便在迭代过程中更有效地搜索或处理数据

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        //双指针法 (相向双指针法)
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            if (nums[left] == val) {
                nums[left] = nums[right];
                right--;    //注意这里right赋给left后就该减了
            } else {
                // 这里兼容了right指针指向的值与val相等的情况 和 left 没有指向 val 的情况
                left++;
            }
        }
        return left;//刚好"新"数组末尾的下一个下标 left 就是形成的"新"数组的大小
    }
}
```

**复杂度分析**

- 时间复杂度：*O*(*n*), 其中 *n* 为序列的长度. 我们只需要遍历该序列至多一次
- 空间复杂度：*O*(1), 我们只需要常数的空间保存若干变量



## 3. 有序数组的平方

## 4. 长度最小的子数组 

## 5.螺旋矩阵 II 

## 6. 区间和 

## 7. 开放商购买土地 

## 8.总结

### 数组理论基础

数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力

也就是说，想法很简单，但实现起来 可能就不是那么回事了。

首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题

**数组是存放在连续内存空间上的相同类型数据的集合。**

数组可以方便的通过下标索引的方式获取到下标对应的数据。

举一个字符数组的例子，如图所示：

![img](images/%E6%95%B0%E7%BB%84/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png)

需要两点注意的是

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

正是**因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：

![img](images/%E6%95%B0%E7%BB%84/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)

而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。

**数组的元素是不能删的，只能覆盖。**

那么二维数组直接上图，大家应该就知道怎么回事了

![img](images/%E6%95%B0%E7%BB%84/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%842.png)

**那么二维数组在内存的空间地址是连续的么？**

我们来举一个Java的例子，例如： `int[][] rating = new int[3][4];` ， 这个二维数组在内存空间可不是一个 `3*4` 的连续地址空间

看了下图，就应该明白了：

![img](images/%E6%95%B0%E7%BB%84/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%843.png)

所以**Java的二维数组在内存中不是 `3\*4` 的连续地址空间，而是四条连续的地址空间组成！**

### 数组的经典题目

在面试中，数组是必考的基础数据结构。

其实数组的题目在思想上一般比较简单的，但是如果想高效，并不容易。

我们之前一共讲解了四道经典数组题目，每一道题目都代表一个类型，一种思想。

#### 二分法

[数组：每次遇到二分法，都是一看就会，一写就废(opens new window)](https://programmercarl.com/0704.二分查找.html)

这道题目呢，考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。

可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目

- 暴力解法时间复杂度：O(n)
- 二分法时间复杂度：O(logn)

在这道题目中我们讲到了**循环不变量原则**，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。

**二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力**。

#### 双指针法

- [数组：就移除个元素很难么？(opens new window)](https://programmercarl.com/0027.移除元素.html)

双指针法（快慢指针法）：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

- 暴力解法时间复杂度：O(n^2)
- 双指针时间复杂度：O(n)

这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点：

- 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。
- C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。

双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。

#### 滑动窗口

- [数组：滑动窗口拯救了你(opens new window)](https://programmercarl.com/0209.长度最小的子数组.html)

本题介绍了数组操作中的另一个重要思想：滑动窗口。

- 暴力解法时间复杂度：O(n^2)
- 滑动窗口时间复杂度：O(n)

本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。

**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。

#### 模拟行为

- [数组：这个循环可以转懵很多人！(opens new window)](https://programmercarl.com/0059.螺旋矩阵II.html)

模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。

在这道题目中，我们再一次介绍到了**循环不变量原则**，其实这也是写程序中的重要原则。

相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实**真正解决题目的代码都是简洁的，或者有原则性的**，大家可以在这道题目中体会到这一点。

#### 前缀和

> 代码随想录后续补充题目

- [数组：求取区间和(opens new window)](https://programmercarl.com/kamacoder/0058.区间和.html)

前缀和的思路其实很简单，但非常实用，如果没接触过的录友，也很难想到这个解法维度，所以 这是开阔思路 而难度又不高的好题。

### 总结图

![img](images/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)

这个图是 [代码随想录知识星球 (opens new window)](https://programmercarl.com/other/kstar.html)成员：[海螺人 (opens new window)](https://wx.zsxq.com/dweb2/index/footprint/844412858822412)，所画，总结的非常好，分享给大家。

从二分法到双指针，从滑动窗口到螺旋矩阵，相信如果大家真的认真做了「代码随想录」每日推荐的题目，定会有所收获。

推荐的题目即使大家之前做过了，再读一遍文章，也会帮助你提炼出解题的精髓所在。